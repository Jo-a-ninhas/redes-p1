#!/usr/bin/env python3
import asyncio
from ctypes import sizeof
from logging import exception
import re
import queue
from tcp import Servidor


def validar_nome(nome):
    return re.match('^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()

def ping(conexao, payload):
    conexao.enviar(b':server PING server :' + payload.split(b' ', 1)[1])
    
def nick(conexao, dados):
    #Nickname inválido
    if not(validar_nome(dados)):
        conexao.enviar((f'server 432 {dados} {dados} :Erroneous nickname\n').encode('UTF-8'))
        return

    current_nickname = '*'
    if conexao in list(connections.values()):
        current_nickname = list(connections.keys())[list(connections.values()).index(conexao)]
    
    #Nickname disponível
    if not dados.lower() in [conn.lower() for conn in connections]:
        if current_nickname == '*':
            conexao.enviar((f':server 001 {dados} :Welcome\n').encode('UTF-8'))
            conexao.enviar((f':server 422 {dados} :MOTD File is missing\n').encode('UTF-8'))
        else:
            conexao.enviar((f':{current_nickname} NICK {dados}\n').encode('UTF-8'))
            del connections[current_nickname]
        connections[dados.lower()] = conexao
        return    

    #Nickname indisponível
    else:
        conexao.enviar((f':server 433 {current_nickname} {dados} :Nickname is already in use').encode('UTF-8'))
        return

#Ta case sensitive isso?
def send_message(conexao, dados):
    remetente = '*'
    if conexao in list(connections.values()):
        remetente = list(connections.keys())[list(connections.values()).index(conexao)]

    receiver = connections.get(dados.split(' ', 1)[0].lower())
    if receiver is not None:
        message = (dados.split(' ', 1)[1]).encode('UTF-8')
        receiver.enviar((f'{remetente} PRIVMSG {dados.split(' ', 1)[0].lower()} :{message}').encode('UTF-8'))
    

def print_users(conexao):
    for users in connections:
        conexao.enviar((users + '\n').encode('UTF-8'))


    #<FUNCAO> msg\r\n 
def dados_recebidos(conexao, dados):
    if dados == b'':
        print("Dados vazios")
        return sair(conexao)
    print(conexao, dados)

    dadosTratados = str(dados)[2:-5].split(' ', 1)
    
    if dadosTratados[0] == 'PING':
        ping(conexao, dados)

    if dadosTratados[0] == 'NICK':
        nick(conexao, dadosTratados[1])

    if dadosTratados[0] == 'PRIVMSG' or dadosTratados[0]=='msg':
        send_message(conexao, dadosTratados[1])

    if dadosTratados[0] == 'usrs':
        print_users(conexao)


    mensagem = b''

    # É preciso fazer o tratamento dos dados antes e assim que a mensagem estiver completa, o comando PART é implementado da seguinte forma:
    # if mensagem.startswith():
    #     canal = mensagem.split(b' ')[1] # Obtem-se o nome do canal que pode vir junto com um '\r'
    #     nome_canal = canal.split(b'\r')[0] # Obtem-se somente o nome do canal

    #     usuario = identifica_usuario(conexao).lower() # Dicionário para mapear cada apelido para a conexão
        
    #     for apelido in canais[nome_canal]: # Identifica cada participante do grupo e manda a mensagem de saída do usuário
    #         conexao_participante = identifica_conexao(apelido)
    #         conexao_participante.enviar(b':' + user + b' PART ' + nome_canal + b'\r\n')

    #     canais[nome_canal].remove(usuario) # Remove usuário do grupo

    #     mensagem = b''


def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)

connections = dict()
servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
